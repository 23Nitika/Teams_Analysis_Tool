<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Analysis Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    .charts-wrapper {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        padding: 20px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        margin: 20px 0;
    }

    .chart-box {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .chart-title {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        margin-bottom: 15px;
        text-align: center;
    }

    @media (max-width: 768px) {
        .charts-wrapper {
            grid-template-columns: 1fr;
        }
    }
    .instruction-box {
      background-color: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .button-container {
      display: flex;
      gap: 20px;
      align-items: center;
      margin: 20px 0;
    }

    button, select {
      height: 40px;
      padding: 0 20px;
      border-radius: 5px;
      border: none;
      background-color: #0066cc;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0052a3;
    }

    select {
      background-color: white;
      color: #333;
      border: 1px solid #ddd;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }

    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #333;
      color: white;
      padding: 15px 25px;
      border-radius: 5px;
      display: none;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); }
      to { transform: translateX(0); }
    }

    .chart-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .chart {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #table-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-top: 20px;
      overflow: hidden;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
    }

    .data-table th {
      background: #0066cc;
      color: white;
      padding: 12px;
      text-align: left;
    }

    .data-table td {
      padding: 12px;
      border-bottom: 1px solid #eee;
    }

    .data-table tr:hover {
      background-color: #f8f9fa;
    }

    .pending-tasks-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 20px 0;
      padding: 20px;
    }

    .table-wrapper {
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
    }

    .data-table th {
      background: #3498db;
      color: white;
      padding: 12px;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .data-table td {
      padding: 12px;
      border-bottom: 1px solid #eee;
    }

    .template-item {
      margin-bottom: 15px;
    }

    .template-item label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .template-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }

    .template-modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 18px;
      font-weight: bold;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
    }

    .template-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }

    @media (max-width: 768px) {
      .template-grid {
        grid-template-columns: 1fr;
      }
    }

    .row-container {
      background-color: #f9f9f9;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      border: 1px solid #eee;
      position: relative;
    }

    .row-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .row-number {
      font-weight: bold;
      color: #0066cc;
    }

    .delete-row {
      background: none;
      border: none;
      color: #ff4d4d;
      cursor: pointer;
      font-size: 16px;
      padding: 0;
      height: auto;
    }

    .add-row-btn {
      width: 100%;
      margin: 15px 0;
      background-color: #00aa55;
    }

    .template-rows {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 5px;
    }

    .template-rows::-webkit-scrollbar {
      width: 6px;
    }

    .template-rows::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .template-rows::-webkit-scrollbar-thumb {
      background: #0066cc;
      border-radius: 3px;
    }
    .canvas {
  min-height: 300px;
  width: 100% !important;
}
  </style>
</head>
<body>
  <div class="instruction-box">
    <h2>Team Analysis Dashboard</h2>
    <p>1. Select your team from the dropdown</p>
    <p>2. Download and fill the template following your team's status nomenclature:</p>
    <ul>
      <li>Installation: "Installation Work in Progress", "Installation Done", "Installation Not Done"</li>
      <li>Integration: "Integration Work in Progress", "Integration Done", "Integration Not Done"</li>
      <li>RFAI Survey: "RFAI Survey in Progress", "RFAI Survey Done", "RFAI Survey Not Done"</li>
      <li>MO Punching: "MO Punching Work in Progress", "MO Punching Done", "MO Punching Not Done"</li>
    </ul>
    <p>3. Upload your filled template with the correct team password to view analysis</p>
  </div>

  <div class="button-container">
    <select id="teamSelect" onchange="handleTeamChange()">
      <option value="">Select Team</option>
      <option value="installation">Installation Team</option>
      <option value="integration">Integration Team</option>
      <option value="rfaiSurvey">RFAI Survey Team</option>
      <option value="moPunching">MO Punching Team</option>
      <option value="pobo">POBO Team</option>
      <option value="materialDelivery">Material Delivery Team</option>
      <option value="pri">PRI Team</option>
    </select>
    <!-- Add Circle Dropdown Here -->
  <select id="circleSelect" onchange="handleCircleChange()">
    <option value="">All Circles</option>
    <option value="Delhi">Delhi</option>
    <option value="Nepal">Nepal</option>
    <option value="AP">AP</option>
    <option value="Assam">Assam</option>
    <option value="Chennai">Chennai</option>
    <option value="Haryana">Haryana</option>
    <option value="HP">HP</option>
    <option value="ROTN">ROTN</option>
    <option value="UPW">UPW</option>
    <option value="J&K">J&K</option>
    <option value="Raj">Raj</option>
    <option value="Karnatka">Karnatka</option>
  </select>
  
  
</div>
    <button onclick="downloadTeamTemplate()">Download Template</button>
    <input type="file" id="fileInput" accept=".xlsx, .xls" style="display: none;" />
    <button onclick="document.getElementById('fileInput').click()">Upload File</button>
  </div>


  <div id="passwordModal" class="modal">
    <div class="modal-content">
      <h3>Enter Team Password</h3>
      <input type="password" id="passwordInput" style="width: 100%; padding: 8px; margin: 10px 0;">
      <button onclick="validatePassword()">Submit</button>
    </div>
  </div>

  <div id="templateModal" class="template-modal">
    <div class="template-modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Create Multi-Row Template</h3>
        <button class="close-button" onclick="closeTemplateModal()">&times;</button>
      </div>
      
      <div id="templateRows" class="template-rows">
        <!-- Template rows will be added here dynamically -->
      </div>
      
      <button class="add-row-btn" onclick="addTemplateRow()">+ Add Row</button>
      
      <div style="margin-top: 20px; text-align: center;">
        <button onclick="downloadCustomTemplate()">Download Template</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="analysisResults"></div>
  <div id="table-container"></div>
  <div id="pendingTasksContainer"></div>

  <script>
    // Updated teamConfigs object with the three new teams
const teamConfigs = {
  installation: {
    password: 'install123',
    validStatuses: [
      'Partially Complete',
      'Installation Done',
      'Installation Not Done',
      'Complete with Issue'
    ],
    validRemarks: [
    'Material Shortage', 
      'Infra Issue', 
      'Access/owner/Community Issue', 
      'Power Issue', 
      'Mount Issue', 
      'Environmental Issue(Nest, Hive, Water logging vegitation etc)', 
      'Hold by Bharti', 
      'Jumper Mismatch', 
      'H/W Faulty', 
      'GSM Issue', 
      'WIP', 
      'To Start', 
      'MCB Issue', 
      'Water Logging Issue', 
      'Theft Issue', 
      'RMO / SRN', 
      'Planning Change', 
      'Access Approval Awaited', 
      'Weekend Access Only', 
      'Additional material required', 
      'Completed with Alarm', 
      'Media Issue', 
      'Team not Available',
      'ASP drop'
    ]
  },
  integration: {
    password: 'integrate123',
    validStatuses: [
      'Integration Done with Alarm',
      'Integration Done',
      'Integration Not Done',
    ],
    validRemarks: [
      'Media Issue', 
      'HW Faulty', 
      'Script NA', 
      'Fme NA', 
      'SACFA Pending', 
      'Power issue', 
      'LAC Issue', 
      'Access/owner/Community Issue', 
      'WIP', 
      'Infra issue', 
      'Hold By Customer', 
      'RMO', 
      'LKF Pending', 
      'Media Pending', 
      'J2 pending', 
      'Integration Completed'
    ]
  },
  rfaiSurvey: {
    password: 'rfai123',
    validStatuses: [
      'RFAI Survey Done',
      'Survey Fail-access',
      'Survey Fail-infra',
      'Survey Planned',
      'Not Plannned-Team Consumed',
      'Not Planned-High RFAI',
      'Pending-Team Drop',
      'Pending-Access Issue',
      'Pending-Weekend access'
    ],
    validRemarks: [
      'Environmental Issue(Nest, Hive, Water logging vegitation etc)', 
      'Access/owner/Community Issue', 
      'Pole Mount height diffrence Issue', 
      'Weekend Issue', 
      'Power Issue', 
      'Infra Issue', 
      'Survey To Plan', 
      'OK for MO', 
      'Pole Mount NA', 
      'Mcb issue', 
      'Mcb and Pole Mount NA', 
      'OHS Issue', 
      'HCT Tray Issue', 
      'OD Bed/Pole NA', 
      'Others', 
      'J2 pending', 
      'Boundary Wall', 
      'EB Issue', 
      'PoP not ready', 
      'LoS Issue', 
      'Battery Bank NA', 
      'Nominal Hold', 
      'RFAI Received', 
      'RFAI Accepted', 
      'RFAI Rejected', 
      'CF-RFAI Accepted'
    ]
  },
  moPunching: {
    password: 'mopunch123',
    validStatuses: [
      'Dispatch Done',
      'MO Done',
      'MO Not Done',
      'Dispatch Hold'
    ],
    validRemarks: [
      'Mo to Raise', 
      'On Hold stock issue',
      'On Hold BOQ', 
      'Short Material', 
      'Cancelled IM', 
      'Cancelled WH', 
      'On Hold By customer', 
      'Planning issue', 
      'Others', 
      'Oracle Issue/WH closed', 
      'Hold by WH', 
      'Nominal Hold', 
      'Vehicle NA', 
      'To Dispatch', 
      'Material On Hold Prestaging', 
      'On Hold Vehicle Issue', 
      'On Hold WH Issue', 
      'On Hold By Bharti', 
      'On Hold Access Issue', 
      'In Transit', 
      'Access/owner/Community Issue', 
      'RMO', 
      'Material Incorrect Delivery', 
      'Partial material delivered', 
      'Material Delivered at wrong location', 
      'Vehicle breakdown'
    ]
  },
  // New POBO team
  pobo: {
    password: 'pobo123',
    validStatuses: [
      'RFAI Accepted for Survey',
      'Planning input incorrect',
      'Rfai Hold',
      'Descope'
    ],
    validRemarks: [
      'RFAI Accepted for Survey',
      'Planning input incorrect',
      'Rfai Hold',
      'Descope'
    ]
  },
  // New Material Delivery team
  materialDelivery: {
    password: 'material123',
    validStatuses: [
      'Material In Transit',
      'Material Delivery Done',
      'Material Returned'
    ],
    validRemarks: [
      'In Transit',
      'Access/owner/Community Issue',
      'RMO',
      'Material Incorrect Delivery',
      'Partial material delivered',
      'Material Delivered at wrong location',
      'Vehicle breakdown',
      'Material on site'
    ]
  },
  // New PRI team
  pri: {
    password: 'pri123',
    validStatuses: [
      'PRI Work in Progress',
      'PRI Done',
      'PRI Not Done',
      'PRI Status Not Available'
    ],
    validRemarks: [
      'Environmental Issue(Nest, Hive, Water logging vegitation etc)',
      'Access/owner/Community Issue',
      'Pole Mount height diffrence Issue',
      'Weekend Issue',
      'Power Issue',
      'Infra Issue',
      'Mcb issue',
      'Mcb and Pole Mount NA',
      'Pole Mount NA',
      'HCT Tray Issue',
      'OD Bed/Pole NA',
      'Boundary Wall',
      'EB Issue',
      'On Hold',
      'Access Issue',
      'To be Survey',
      'To be Mo Punch',
      'To be Dispatch',
      'To be Delivered',
      'To be Install',
      'To be integration'
    ]
  }
};

    let currentTeam = '';
    let currentFile = null;
    let currentCircle = '';
    let templateRows = []; // Array to store multiple template rows
    // Array to store template row data
    let visibleRowsCount = 0; // Track number of rows actually rendered in DOM
    const MAX_VISIBLE_ROWS = 50; // Maximum number of rows to show in the UI at once
    let totalRowCount = 0; //

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => {
        toast.style.display = 'none';
      }, 3000);
    }
    // Add event listener for file input changes
    document.getElementById('fileInput').addEventListener('change', function(e) {
      if (!currentTeam) {
        showToast('Please select a team first');
        return;
      }
      
      const file = e.target.files[0];
      if (!file) return;
      
      currentFile = file;
      
      // Show password modal
      const modal = document.getElementById('passwordModal');
      modal.style.display = 'block';
    });

    function validatePassword() {
      const password = document.getElementById('passwordInput').value;
      const teamConfig = teamConfigs[currentTeam];
      
      if (password === teamConfig.password) {
        // Hide modal
        document.getElementById('passwordModal').style.display = 'none';
        
        // Process file
        processFile(currentFile);
        
        // Clear password field
        document.getElementById('passwordInput').value = '';
      } else {
        showToast('Invalid password');
      }
    }

    function handleTeamChange() {
      currentTeam = document.getElementById('teamSelect').value;
      if (!currentTeam) {
        showToast('Please select a team');
        return;
      }
      showToast(`Selected ${currentTeam} team`);
    }
    function handleCircleChange() {
  currentCircle = document.getElementById('circleSelect').value;
  
  // If we already have data loaded, update the visualization with the filtered data
  if (currentFile && document.getElementById('analysisResults').innerHTML !== '') {
    // Retrieve stored data for the current file
    const uploadedFiles = JSON.parse(localStorage.getItem('uploadedFiles') || '[]');
    const currentFileInfo = uploadedFiles.find(file => file.name === currentFile.name);
    
    if (currentFileInfo) {
      const storedData = JSON.parse(localStorage.getItem(`fileData_${currentFileInfo.timestamp}`) || '[]');
      
      // Apply circle filter and update display
      displayAnalysis(storedData);
    }
  }
  
  if (currentCircle) {
    showToast(`Filtered by ${currentCircle} circle`);
  } else {
    showToast('Showing all circles');
  }
}
    
    async function downloadTeamTemplate() {
  const team = document.getElementById("teamSelect").value;
  if (!team) {
    showToast("Please select a team first");
    return;
  }

  try {
    // First, try the server-side approach
    const response = await fetch(`/api/generate-template/${team}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const blob = await response.blob();
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `${team}_template.xlsx`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      showToast("Template downloaded successfully");
    } else {
      // Fall back to client-side generation if server fails
      generateClientSideTemplate(team);
    }
  } catch (error) {
    console.error("Error downloading template:", error);
    // Fall back to client-side generation
    showToast("Server connection failed, generating template locally");
    generateClientSideTemplate(team);
  }
}
function generateClientSideTemplate(team) {
  // Get team configuration
  const teamConfig = teamConfigs[team];
  if (!teamConfig) {
    showToast('Invalid team selected');
    return;
  }
  
  try {
    // Create a new workbook
    const workbook = XLSX.utils.book_new();
    
    // Create data sheet with headers - add Circle column
    const headers = ['Activity Date', 'Activity Status', 'Circle', 'Unique ID', 'Remarks'];
    const dataRows = [headers];
    
    // Add 20 empty rows as examples with today's date
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    for (let i = 0; i < 20; i++) {
      dataRows.push([
        today,
        '',
        '',  // Circle will be empty in template
        '',
        ''
      ]);
    }
    
    const dataSheet = XLSX.utils.aoa_to_sheet(dataRows);
    
    // Set column widths
    const dataCols = dataSheet['!cols'] = [];
    dataCols[0] = { wch: 15 }; // Date
    dataCols[1] = { wch: 30 }; // Status
    dataCols[2] = { wch: 15 }; // Circle - added
    dataCols[3] = { wch: 20 }; // ID
    dataCols[4] = { wch: 40 }; // Remarks
    
    // Add data sheet and validation sheet (rest of the code remains the same)
    XLSX.utils.book_append_sheet(workbook, dataSheet, 'Data');
    
    // Add validation data sheet (hidden) - now add Circle values too
    const validationSheet = XLSX.utils.aoa_to_sheet([
      ['Status Values'],
      ...teamConfig.validStatuses.map(status => [status]),
      [''],
      ['Circle Values'],
      ['Delhi'],
      ['Nepal'],
      ['AP'],
      ['Assam'],
      ['Chennai'],
      ['Haryana'],
      ['HP'],
      ['ROTN'],
      ['UPW'],
      ['J&K'],
      [''],
      ['Remarks Values'],
      ...teamConfig.validRemarks.map(remark => [remark])
    ]);
    
    // Add validation sheet
    XLSX.utils.book_append_sheet(workbook, validationSheet, 'Validation_Data');
    
    // Download the file
    XLSX.writeFile(workbook, `${team}_template.xlsx`);
    
    showToast('Template created successfully');
  } catch (error) {
    console.error('Error generating template:', error);
    showToast('Error creating template');
  }
}
    function showTemplateModal() {
  if (!currentTeam) {
    showToast('Please select a team first');
    return;
  }
  
  // Generate and download template directly
  downloadTeamTemplate();
}
function generateSimpleTemplate() {
  // Get team configuration
  const teamConfig = teamConfigs[currentTeam];
  if (!teamConfig) {
    showToast('Invalid team selected');
    return;
  }
  
  showToast('Generating template for ' + currentTeam + ' team...');
  
  try {
    // Create a new workbook
    const workbook = XLSX.utils.book_new();
    
    // Create worksheet with instructions
    const instructionsSheet = XLSX.utils.aoa_to_sheet([
      ['Team Analysis Template - ' + currentTeam.toUpperCase()],
      [''],
      ['Instructions:'],
      ['1. Fill out the template with your team data'],
      ['2. Do not modify the column headers or sheet structure'],
      ['3. Use the dropdown values provided in the Status and Remarks columns'],
      ['4. Each row must have a unique ID'],
      ['5. Save the file and upload it to the dashboard'],
      [''],
      ['Valid Status Values:'],
      ['- ' + teamConfig.validStatuses.join('\n- ')],
      [''],
      ['Valid Remarks Values:'],
      ['- ' + teamConfig.validRemarks.join('\n- ')]
    ]);
    
    // Set column widths for better readability
    const instructionsCols = instructionsSheet['!cols'] = [];
    instructionsCols[0] = { wch: 80 }; // Width of first column
    
    // Add instructions sheet
    XLSX.utils.book_append_sheet(workbook, instructionsSheet, 'Instructions');
    
    // Create data sheet with headers
    const headers = ['Activity Date', 'Activity Status', 'Unique ID', 'Remarks'];
    const dataRows = [headers];
    
    // Add 20 empty rows as examples with today's date
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    for (let i = 0; i < 20; i++) {
      dataRows.push([
        today,
        teamConfig.validStatuses[0],
        '',
        teamConfig.validRemarks[0]
      ]);
    }
    
    const dataSheet = XLSX.utils.aoa_to_sheet(dataRows);
    
    // Set column widths
    const dataCols = dataSheet['!cols'] = [];
    dataCols[0] = { wch: 15 }; // Date
    dataCols[1] = { wch: 30 }; // Status
    dataCols[2] = { wch: 20 }; // ID
    dataCols[3] = { wch: 40 }; // Remarks
    
    // Add data sheet
    XLSX.utils.book_append_sheet(workbook, dataSheet, 'Data');
    
    // Add validation data sheet (hidden)
    const validationSheet = XLSX.utils.aoa_to_sheet([
      ['Status Values'],
      ...teamConfig.validStatuses.map(status => [status]),
      [''],
      ['Remarks Values'],
      ...teamConfig.validRemarks.map(remark => [remark])
    ]);
    
    // Add validation sheet
    XLSX.utils.book_append_sheet(workbook, validationSheet, 'Validation_Data');
    
    // Download the file
    XLSX.writeFile(workbook, `${currentTeam}_template.xlsx`);
    
    showToast('Template created successfully');
  } catch (error) {
    console.error('Error generating template:', error);
    showToast('Error creating template');
  }
}


 
  
  
function downloadTemplate() {
  if (!currentTeam) {
    showToast('Please select a team first');
    return;
  }
  
  downloadTeamTemplate();
}
function processFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array', cellStyles: true, cellDates: true });
      
      // Find the Data sheet
      const dataSheetName = workbook.SheetNames.find(name => 
        name.toLowerCase() === 'data'
      ) || workbook.SheetNames[0]; // Fallback to first sheet if "Data" not found
      
      if (!dataSheetName) {
        showToast('Error: No data sheet found in the uploaded file.');
        return;
      }
      
      const sheet = workbook.Sheets[dataSheetName];
      
      // Get the full range of the sheet
      const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1:D1');
      
      // Get the headers from the first row
      const headers = [];
      const expectedHeaders = ['Activity Date', 'Activity Status', 'Unique ID', 'Remarks','Circle'];
      
      // Extract headers from the first row
      for (let c = range.s.c; c <= range.e.c; c++) {
        const cell = sheet[XLSX.utils.encode_cell({r: 0, c})];
        if (cell && cell.v) {
          headers[c] = cell.v.toString().trim();
        } else {
          // If header is missing, use default expected header
          headers[c] = expectedHeaders[c] || `Column${c+1}`;
        }
      }
      
      // Extract data rows (skip header row)
      const jsonData = [];
      for (let r = 1; r <= range.e.r; r++) {
        const row = {};
        let hasData = false;
        
        for (let c = 0; c <= range.e.c; c++) {
          const cellAddress = XLSX.utils.encode_cell({r, c});
          const cell = sheet[cellAddress];
          
          if (cell) {
            let value;
            
            // Handle different cell types
            if (cell.t === 'd') {
              // Date type
              value = cell.w || new Date(cell.v).toISOString().split('T')[0];
            } else if (cell.t === 'n' && headers[c] === 'Activity Date') {
              // Numeric date
              value = new Date(Math.round((cell.v - 25569) * 86400 * 1000))
                .toISOString().split('T')[0];
            } else {
              // Other types (string, boolean, etc.)
              value = cell.v;
              
              // Ensure value is string for dropdown selections
              if (value !== undefined && value !== null) {
                value = value.toString().trim();
              }
            }
            
            // Map value to proper header
            if (headers[c]) {
              row[headers[c]] = value;
              
              // Check if this row has meaningful data
              if (value !== undefined && value !== null && value !== '') {
                hasData = true;
              }
            }
          } else if (headers[c]) {
            // Cell doesn't exist, use empty value
            row[headers[c]] = '';
          }
        }
        
        // Only add rows that have data
        if (hasData) {
          jsonData.push(row);
        }
      }
      
      console.log("Extracted data from file:", jsonData);
      
      if (jsonData.length === 0) {
        showToast('Error: No data found in the uploaded file.');
        return;
      }

      // Process and clean data to ensure all expected fields are present
      const processedData = jsonData
        .filter(row => {
          // Filter out rows without required data
          return row['Unique ID'] || 
                (row['Activity Date'] && row['Activity Status']);
        })
        .map(row => {
          // Ensure all expected fields are present
          const cleanedRow = {};
          expectedHeaders.forEach(header => {
            cleanedRow[header] = row[header] !== undefined ? row[header] : '';
          });
          return cleanedRow;
        });
      
      console.log("Processed data:", processedData);
      
      if (processedData.length === 0) {
        showToast('Error: No valid data found after processing.');
        return;
      }
      
      
      // Display analysis with the cleaned data
      displayAnalysis(processedData);
      storeProcessedData(processedData, file.name);
      
      // Show success message
      showToast(`Successfully processed ${processedData.length} records`);
      
    } catch (error) {
      console.error("Error processing file:", error);
      showToast('Error processing file: ' + (error.message || 'Unknown error'));
    }
  };
  
  reader.onerror = function() {
    showToast('Error reading file');
  };
  
  reader.readAsArrayBuffer(file);
}
// Add this function to help debug localStorage issues
const debugLocalStorage = () => {
    console.log('===== localStorage Debug Information =====');
    console.log('Total items in localStorage:', Object.keys(localStorage).length);
    
    // Check for uploadedFiles entry
    const uploadedFiles = localStorage.getItem('uploadedFiles');
    console.log('uploadedFiles exists:', !!uploadedFiles);
    if (uploadedFiles) {
        try {
            const parsedFiles = JSON.parse(uploadedFiles);
            console.log('Number of uploaded files:', parsedFiles.length);
            console.log('File details:', parsedFiles);
            
            // Check for each file's data
            parsedFiles.forEach(file => {
                const fileKey = `fileData_${file.timestamp}`;
                const fileData = localStorage.getItem(fileKey);
                console.log(`Data for ${file.name} (key: ${fileKey}) exists:`, !!fileData);
                if (fileData) {
                    try {
                        const parsedData = JSON.parse(fileData);
                        console.log(`Records in ${file.name}:`, parsedData.length);
                        console.log('Sample record:', parsedData[0]);
                    } catch (e) {
                        console.error(`Cannot parse data for ${file.name}:`, e);
                    }
                }
            });
        } catch (e) {
            console.error('Cannot parse uploadedFiles:', e);
        }
    }
    
    // List all localStorage keys that might be relevant
    console.log('All localStorage keys:');
    Object.keys(localStorage).forEach(key => {
        if (key.startsWith('fileData_') || key.includes('file') || key.includes('data')) {
            console.log(`- ${key} (size: ${localStorage.getItem(key).length} chars)`);
        }
    });
    console.log('===== End Debug Information =====');
};

// Call this in componentDidMount or at the beginning of loadAllData
debugLocalStorage();
function validateDataFormat(data) {
  // Basic check - is it an array with content
  if (!Array.isArray(data) || data.length === 0) {
    console.error("Data is empty or not an array");
    return false;
  }

  // Required columns we need
  const requiredColumns = ['Activity Date', 'Activity Status', 'Unique ID', 'Remarks'];
  
  // Count how many rows have required data
  const validRows = data.filter(row => {
    // For a row to be valid, it needs at least Unique ID or Activity Date
    return row && (row['Unique ID'] || row['Activity Date']);
  });
  
  // Log validation results
  console.log(`Validation: Total rows: ${data.length}, Valid rows: ${validRows.length}`);
  
  // If no valid rows, return false
  if (validRows.length === 0) {
    return false;
  }
  
  // Return success
  return true;
}
function storeProcessedData(processedData, fileName) {
  try {
    // Get existing uploaded files or initialize an empty array
    const uploadedFiles = JSON.parse(localStorage.getItem('uploadedFiles') || '[]');
    
    // Create a unique timestamp for this file
    const timestamp = new Date().getTime();
    
    // Add metadata about this file
    uploadedFiles.push({
      name: fileName,
      timestamp: timestamp,
      records: processedData.length,
      uploadDate: new Date().toISOString()
    });
    
    // Save the updated file list
    localStorage.setItem('uploadedFiles', JSON.stringify(uploadedFiles));
    
    // Save the actual data
    localStorage.setItem(`fileData_${timestamp}`, JSON.stringify(processedData));
    
    console.log(`Stored file ${fileName} with ${processedData.length} records using key fileData_${timestamp}`);
    
    // Debug to verify data is stored correctly
    debugLocalStorage();
    
    return true;
  } catch (error) {
    console.error("Error storing processed data:", error);
    return false;
  }
}

function validateAndDisplayData(data) {
  const cleanedData = data.map(row => {
    // Trim whitespace from all string values
    const cleanedRow = {};
    Object.keys(row).forEach(key => {
      // Convert to string and trim if it's a string
      cleanedRow[key] = typeof row[key] === 'string' 
        ? row[key].trim() 
        : row[key];
    });

    // Provide default values if crucial fields are missing or empty
    cleanedRow['Activity Status'] = cleanedRow['Activity Status'] || 'Status Not Available';
    cleanedRow['Remarks'] = cleanedRow['Remarks'] || 'No remarks';
    
    return cleanedRow;
  });

  // Filter out completely empty rows
  const filteredData = cleanedData.filter(row => 
    row['Unique ID'] || row['Activity Date']
  );

  // If no valid rows remain, show an error
  if (filteredData.length === 0) {
    showToast('Error: No valid data found in the file');
    return;
  }

  // Store consolidated data for the team
  storeConsolidatedData(filteredData);

  // Clear previous analysis results before displaying new ones
  const resultsDiv = document.getElementById('analysisResults');
  resultsDiv.innerHTML = '';

  // Display analysis with the cleaned and filtered data
  displayAnalysis(filteredData);

  // Optional: Show a toast with data cleaning info
  showToast(`Processed ${filteredData.length} records after cleaning`);
}
function storeConsolidatedData(data) {
  // Store the data with additional metadata
  const fileInfo = {
    name: currentFile.name,
    timestamp: Date.now(),
    team: currentTeam,
    status: 'Processed',
    recordCount: data.length
  };

  // Get existing files array or create new one
  const existingFiles = JSON.parse(localStorage.getItem('uploadedFiles') || '[]');
  existingFiles.push(fileInfo);
  localStorage.setItem('uploadedFiles', JSON.stringify(existingFiles));

  // Store the actual data with the timestamp as key
  localStorage.setItem(`fileData_${fileInfo.timestamp}`, JSON.stringify(data));
}

function displayAnalysis(data) {
  // First, ensure Chart.js is loaded
  if (typeof Chart === 'undefined') {
    console.error("Chart.js library is not loaded");
    showToast("Chart.js library is not loaded. Please check your script includes.");
    return;
  }
  
  // Validate input data
  if (!data || !Array.isArray(data) || data.length === 0) {
    showToast('Error: No valid data available for analysis');
    return;
  }
  
  // Filter data by selected circle if one is selected
  let filteredData = data;
  if (currentCircle && currentCircle !== 'All Circles') {
    filteredData = data.filter(row => row['Circle'] === currentCircle);
    
    // Display message if no data for selected circle
    if (filteredData.length === 0) {
      showToast(`No data found for ${currentCircle} circle`);
      const resultsDiv = document.getElementById('analysisResults');
      if (resultsDiv) {
        resultsDiv.innerHTML = `
          <h2 style="text-align: center; margin-bottom: 30px;">No data for ${currentCircle} circle</h2>
          <p style="text-align: center;">Try selecting a different circle or "All Circles"</p>
        `;
      }
      return;
    }
  }
  
  console.log("Displaying analysis for", filteredData.length, "records", currentCircle ? `(filtered by ${currentCircle} circle)` : '(all circles)');
  
  // Get the display container
  const resultsDiv = document.getElementById('analysisResults');
  if (!resultsDiv) {
    console.error("Analysis results div not found");
    return;
  }
  
  // Update heading based on current filter
  const circleText = currentCircle && currentCircle !== 'All Circles' ? ` for ${currentCircle} Circle` : '';
  
  // Clear previous content and set up new chart containers
  resultsDiv.innerHTML = `
    <h2 style="text-align: center; margin-bottom: 30px;">Analysis Results${circleText} (${filteredData.length} records)</h2>
    <div class="charts-wrapper">
      <div class="chart-box">
        <div class="chart-title">Remarks Frequency Analysis${circleText}</div>
        <div style="height: 300px; position: relative;">
          <canvas id="remarksChart"></canvas>
        </div>
      </div>
      <div class="chart-box">
        <div class="chart-title">Status Completion Rate by Circle${circleText}</div>
        <div style="height: 300px; position: relative;">
          <canvas id="statusByCircleChart"></canvas>
        </div>
      </div>
    </div>
  `;

  // Process data and ensure all required fields have defaults
  const processedData = filteredData.map(row => ({
    'Activity Date': row['Activity Date'] || 'Unknown Date',
    'Activity Status': row['Activity Status'] || 'Status Not Available',
    'Circle': row['Circle'] || 'Unknown Circle',
    'Team': row['Team'] || 'Unknown Team',
    'Unique ID': row['Unique ID'] || '',
    'Remarks': row['Remarks'] || 'No remarks'
  }));

  // Get current team
  const team = typeof currentTeam !== 'undefined' ? currentTeam : '';
  
  // Get valid remarks from team configuration
  let validRemarks = [];
  if (team && typeof teamConfigs !== 'undefined' && teamConfigs[team] && teamConfigs[team].validRemarks) {
    validRemarks = teamConfigs[team].validRemarks;
  }

  // Status color function
  function getStatusColor(status, index, alpha) {
    // Define colors for common statuses
    const statusColors = {
      'Done': `rgba(46, 204, 113, ${alpha})`,
      'Completed': `rgba(46, 204, 113, ${alpha})`,
      'Not Done': `rgba(231, 76, 60, ${alpha})`,
      'Work in Progress': `rgba(241, 196, 15, ${alpha})`,
      'In Progress': `rgba(241, 196, 15, ${alpha})`,
      'Pending': `rgba(243, 156, 18, ${alpha})`,
      'Canceled': `rgba(189, 195, 199, ${alpha})`,
      'On Hold': `rgba(52, 152, 219, ${alpha})`
    };
    
    // Check if status contains any of these keywords
    for (const key in statusColors) {
      if (status.includes(key)) {
        return statusColors[key];
      }
    }
    
    // Generate a color based on the index for statuses not in the map
    return `rgba(${100 + index * 30}, ${150 - index * 10}, ${200 - index * 15}, ${alpha})`;
  }

  // Wait for the DOM to be ready with the canvas elements
  setTimeout(() => {
    try {
      // 1. Create Remarks Frequency Analysis
      const remarkCounts = {};
      
      // Count occurrences of each remark
      processedData.forEach(row => {
        const remark = row['Remarks'];
        if (remark && remark !== 'No remarks') {
          remarkCounts[remark] = (remarkCounts[remark] || 0) + 1;
        }
      });
      
      // Sort remarks by frequency and take top 10
      const topRemarks = Object.entries(remarkCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // Create Remarks Chart
      const remarksCanvas = document.getElementById('remarksChart');
      if (!remarksCanvas) {
        console.error("Remarks chart canvas not found");
        return;
      }
      
      // Check if we have remarks data
      if (topRemarks.length === 0) {
        console.warn("No remarks data available for chart");
        remarksCanvas.parentNode.innerHTML = `<div style="text-align: center; padding: 20px;">No remarks data available</div>`;
      } else {
        // Get 2D context
        const remarksCtx = remarksCanvas.getContext('2d');
        
        // Ensure there's no existing chart on this canvas
        if (window.remarksChart instanceof Chart) {
          window.remarksChart.destroy();
        }
        
        // Create new chart
        window.remarksChart = new Chart(remarksCtx, {
          type: 'pie',
          data: {
            labels: topRemarks.map(item => item[0]),
            datasets: [{
              data: topRemarks.map(item => item[1]),
              backgroundColor: topRemarks.map((_, index) => 
                `rgba(${75}, ${192 - index * 10}, ${192 - index * 15}, 0.7)`
              )
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'right',
                labels: {
                  boxWidth: 12,
                  font: {
                    size: 10
                  }
                }
              }
            }
          }
        });
      }

      // 2. Create Status Completion Rate by Circle
      // Calculate status distribution by circle
      const circleStatusData = {};
      const allCircles = new Set();
      const allStatuses = new Set();
      
      // First pass: collect all unique circles and statuses
      processedData.forEach(row => {
        const circle = row['Circle'];
        const status = row['Activity Status'];
        
        allCircles.add(circle);
        allStatuses.add(status);
        
        if (!circleStatusData[circle]) {
          circleStatusData[circle] = {};
        }
        
        if (!circleStatusData[circle][status]) {
          circleStatusData[circle][status] = 0;
        }
        
        circleStatusData[circle][status]++;
      });
      
      // Convert to arrays for charting
      const circleArray = Array.from(allCircles);
      const statusArray = Array.from(allStatuses);
      
      // Create datasets for each status
      const statusDatasets = statusArray.map((status, index) => {
        return {
          label: status,
          data: circleArray.map(circle => 
            (circleStatusData[circle] && circleStatusData[circle][status]) ? 
            circleStatusData[circle][status] : 0
          ),
          backgroundColor: getStatusColor(status, index, 0.7),
          borderColor: getStatusColor(status, index, 1),
          borderWidth: 1
        };
      });
      
      // Create Status by Circle Chart
      const statusCanvas = document.getElementById('statusByCircleChart');
      if (!statusCanvas) {
        console.error("Status chart canvas not found");
        return;
      }
      
      // Check if we have status data
      if (circleArray.length === 0 || statusArray.length === 0) {
        console.warn("No status data available for chart");
        statusCanvas.parentNode.innerHTML = `<div style="text-align: center; padding: 20px;">No status data available</div>`;
      } else {
        // Get 2D context
        const statusByCircleCtx = statusCanvas.getContext('2d');
        
        // Ensure there's no existing chart on this canvas
        if (window.statusByCircleChart instanceof Chart) {
          window.statusByCircleChart.destroy();
        }
        
        // Create new chart
        window.statusByCircleChart = new Chart(statusByCircleCtx, {
          type: 'bar',
          data: {
            labels: circleArray,
            datasets: statusDatasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true,
                grid: {
                  display: false
                },
                title: {
                  display: true,
                  text: 'Circles'
                }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)'
                },
                title: {
                  display: true,
                  text: 'Number of Tasks'
                }
              }
            },
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  font: {
                    size: 10
                  },
                  boxWidth: 10
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  afterTitle: function(tooltipItems) {
                    const circleIndex = tooltipItems[0].dataIndex;
                    const circle = circleArray[circleIndex];
                    
                    // Calculate total for this circle
                    let total = 0;
                    tooltipItems.forEach(item => {
                      total += item.parsed.y;
                    });
                    
                    return `Total: ${total} tasks`;
                  },
                  label: function(context) {
                    const value = context.raw;
                    const dataset = context.dataset;
                    const datasetLabel = dataset.label;
                    
                    // Get total for this circle to calculate percentage
                    const circleIndex = context.dataIndex;
                    const circle = circleArray[circleIndex];
                    let circleTotal = 0;
                    
                    statusArray.forEach(status => {
                      if (circleStatusData[circle] && circleStatusData[circle][status]) {
                        circleTotal += circleStatusData[circle][status];
                      }
                    });
                    
                    const percentage = circleTotal > 0 ? ((value / circleTotal) * 100).toFixed(1) : 0;
                    return `${datasetLabel}: ${value} (${percentage}%)`;
                  }
                }
              }
            }
          }
        });
      }

      // 3. Create Tasks by Circle chart when not filtering
      if (!currentCircle || currentCircle === 'All Circles') {
        // Add a container for the chart
        const circleChartContainer = document.createElement('div');
        circleChartContainer.className = 'charts-wrapper';
        circleChartContainer.style.marginTop = '20px';
        circleChartContainer.innerHTML = `
          <div class="chart-box">
            <div class="chart-title">Tasks by Circle</div>
            <div style="height: 300px; position: relative;">
              <canvas id="circleChart"></canvas>
            </div>
          </div>
        `;
        resultsDiv.appendChild(circleChartContainer);
        
        // Calculate circle distribution
        const circleCounts = {};
        processedData.forEach(row => {
          const circle = row['Circle'] || 'Unknown Circle';
          circleCounts[circle] = (circleCounts[circle] || 0) + 1;
        });
        
        // Create Circle Chart
        const circleCanvas = document.getElementById('circleChart');
        if (!circleCanvas) {
          console.error("Circle chart canvas not found");
          return;
        }
        
        const circleCtx = circleCanvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (window.circleChart instanceof Chart) {
          window.circleChart.destroy();
        }
        
        window.circleChart = new Chart(circleCtx, {
          type: 'bar',
          data: {
            labels: Object.keys(circleCounts),
            datasets: [{
              label: 'Tasks by Circle',
              data: Object.values(circleCounts),
              backgroundColor: Object.keys(circleCounts).map((_, index) => 
                `rgba(${20 + index * 30}, ${100 + index * 15}, ${200 - index * 10}, 0.7)`
              ),
              borderColor: 'white',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return `${context.parsed.x} tasks`;
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true
              }
            }
          }
        });
      }

      // 4. Display pending tasks
      const pendingTasks = filteredData.filter(row => {
        const status = row['Activity Status'] || '';
        // Filter based on status keywords that indicate pending or incomplete work
        return status.includes('Not Done') || 
              status.includes('Work in Progress') ||
              status.includes('in Progress') ||
              (status !== 'Done' && !status.includes('Done'));
      });

      const pendingTasksContainer = document.getElementById('pendingTasksContainer');
      if (pendingTasksContainer) {
        pendingTasksContainer.innerHTML = `
          <div class="pending-tasks-container">
            <h3 class="section-title">Tasks Requiring Attention (${pendingTasks.length})${currentCircle && currentCircle !== 'All Circles' ? ` in ${currentCircle} Circle` : ''}</h3>
            ${pendingTasks.length > 0 ? `
              <div class="table-wrapper">
                <table class="data-table">
                  <thead>
                    <tr>
                      <th>Activity Date</th>
                      <th>Circle</th>
                      <th>Unique ID</th>
                      <th>Status</th>
                      <th>Remarks</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${pendingTasks.map(row => `
                      <tr>
                        <td>${row['Activity Date']}</td>
                        <td>${row['Circle'] || 'N/A'}</td>
                        <td>${row['Unique ID']}</td>
                        <td>${row['Activity Status']}</td>
                        <td>${row['Remarks'] || ''}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : '<p>No pending tasks found.</p>'}
          </div>
        `;
      }
    } catch (error) {
      console.error("Error in chart creation:", error);
      showToast(`Chart creation error: ${error.message}`);
    }
  }, 100); // Small delay to ensure DOM is ready
}

    function getStatusColor(status, index, alpha = 1) {
      const colors = {
        'Done': `rgba(46, 184, 92, ${alpha})`,
        'Not Done': `rgba(235, 87, 87, ${alpha})`,
        'Work in Progress': `rgba(47, 128, 237, ${alpha})`,
        'in Progress': `rgba(47, 128, 237, ${alpha})`
      };

      // Check if status contains any of these keywords
      for (let key in colors) {
        if (status.includes(key)) {
          return colors[key];
        }
      }

      // Fallback colors
      const fallbackColors = [
        `rgba(255, 159, 64, ${alpha})`,
        `rgba(153, 102, 255, ${alpha})`,
        `rgba(75, 192, 192, ${alpha})`
      ];
      return fallbackColors[index % fallbackColors.length];
    }
  </script>
</body>
</html>